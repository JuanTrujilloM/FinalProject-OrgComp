/**
 * Representa un obstáculo HORIZONTAL que cae verticalmente.
 * Consiste en dos muros (izquierdo y derecho) con un hueco vertical en medio.
 */
class HorizontalWall {
    field int y;          // Posición vertical (cambia al caer).
    field int height;     // Grosor del muro.
    field int gap_x;      // Posición 'x' donde empieza el hueco.
    field int gap_width;  // Ancho del hueco.
    field int speed;      // Velocidad de caída.

    /** Constructor: Crea un nuevo muro horizontal. */
    constructor HorizontalWall new(int initial_y, int initial_gap_x, int initial_speed) {
        let y = initial_y;
        let gap_x = initial_gap_x;
        let speed = initial_speed;
        let height = 10;
        let gap_width = 90;

        do draw();
        return this;
    }

    /** Libera la memoria. */
    method void dispose() {
        do Memory.deAlloc(this);
        return;
    }

    /** Dibuja el muro izquierdo y el derecho. */
    method void draw() {
        // Dibuja solo si está dentro de los límites verticales para evitar errores.
        if ((y > -1) & ((y + height) < 256)) {
            do Screen.setColor(true);
            do Screen.drawRectangle(0, y, gap_x, y + height);
            do Screen.drawRectangle(gap_x + gap_width, y, 511, y + height);
        }
        return;
    }

    /** Borra los muros. */
    method void erase() {
        // Borra solo si está dentro de los límites para evitar errores.
        if ((y > -1) & ((y + height) < 256)) {
            do Screen.setColor(false);
            do Screen.drawRectangle(0, y, gap_x, y + height);
            do Screen.drawRectangle(gap_x + gap_width, y, 511, y + height);
            do Screen.setColor(true);
        }
        return;
    }

    /** Mueve el muro hacia abajo. */
    method void fall() {
        do erase();
        let y = y + speed;
        if (y > 255) {
            let y = 0;
            // Cambiar la posición del hueco para el siguiente ciclo.
            let gap_x = (gap_x + 131);
            while (gap_x > 400) {
                let gap_x = gap_x - 400;
            }
            while (gap_x < 20) {
                let gap_x = gap_x + 20;
            }
        }
        do draw();
        return;
    }

    /** Comprueba colisión con el pájaro. */
    method boolean collidesWith(int bird_x, int bird_y, int bird_size) {
        var boolean y_collision, x_collision;
        var int bird_right, bird_bottom;

        let bird_right = bird_x + bird_size;
        let bird_bottom = bird_y + bird_size;

        // 1. Comprobar si el pájaro está a la misma altura que el muro.
        let y_collision = ~((bird_bottom < y) | (bird_y > (y + height)));

        if (y_collision) {
            // 2. Si está a la misma altura, comprobar si está fuera del hueco.
            let x_collision = (bird_x < gap_x) | (bird_right > (gap_x + gap_width));
            if (x_collision) {
                return true;
            }
        }
        return false;
    }
}
