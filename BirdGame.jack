 
class BirdGame {
   // El pájaro de este juego
   field Bird bird;
   // Dirección actual del pájaro: 0=ninguna, 1=arriba, 2=abajo, 3=izquierda, 4=derecha
   field int direction;
   // Array de objetos cayendo
   field Array objects;
   // Número máximo de objetos
   field int maxObjects;
   // Contador para crear nuevos objetos
   field int objectCount;
   // Vidas del jugador
   field int lives;
   // Puntuación del jugador
   field int score;
   // Contador de tiempo para el score
   field int timeCounter;
   // Contador para reactivar objetos
   field int reactivationTimer;

   // Array de muros horizontales
   field Array horizontalWalls;
   // Número máximo de muros
   field int maxWalls;
   // Contador para crear nuevos muros
   field int wallCounter;

   // Construye un nuevo juego BirdGame.
   constructor BirdGame new() {
      var int i;
      // El pájaro inicial está ubicado en el centro de la pantalla (256,128), con tamaño 30 y sin moverse.
      let bird = Bird.new(256, 128, 30);
      let direction = 0;

      // Inicializar sistema de objetos cayendo
      let maxObjects = 5;  // Máximo 5 objetos en pantalla a la vez
      let objects = Array.new(maxObjects);
      let objectCount = 0;
      let lives = 1;  // Comenzar con 1 vidas
      let score = 0;  // Comenzar con score 0
      let timeCounter = 0;  // Inicializar contador de tiempo
      let reactivationTimer = 0;  // Sin objetos por reactivar al inicio
      
      // Inicializar array con null
      let i = 0;
      while (i < maxObjects) {
         let objects[i] = 0;  // null
         let i = i + 1;
      }

      // Inicializar sistema de muros horizontales
      let maxWalls = 3;
      let horizontalWalls = Array.new(maxWalls);
      let wallCounter = 0;

      let i = 0;
      while (i < maxWalls) {
         let horizontalWalls[i] = 0;
         let i = i + 1;
      }

      // Mostrar título y Score
      do showTitle();
      do updateScore();
      
      return this;
   }

   // Libera la memoria del juego.
   method void dispose() {
      var int i;
      var FallingObject obj;
      var HorizontalWall wall;

      // Liberar todos los objetos
      let i = 0;
      while (i < maxObjects) {
         let obj = objects[i];
         if (~(obj = 0)) { do obj.dispose(); }
         let i = i + 1;
      }

      let i = 0;
      while (i < maxWalls) {
         let wall = horizontalWalls[i];
         if (~(wall = 0)) { do wall.dispose(); }
         let i = i + 1;
      }

      do objects.dispose();
      do horizontalWalls.dispose();
      do bird.dispose();
      do Memory.deAlloc(this);
      return;
   }

   // Mueve el pájaro en la dirección actual.
   method void moveBird() {
      if (direction = 1) { do bird.moveUp(); }
      if (direction = 2) { do bird.moveDown(); }
      if (direction = 3) { do bird.moveLeft(); }
      if (direction = 4) { do bird.moveRight(); }
      do Sys.wait(8);  // Retraso para el siguiente movimiento
      return;
   }

   // Ejecuta el juego: maneja las entradas del usuario y mueve el pájaro en consecuencia.
   method void run() {
      var char key;  // La tecla actualmente presionada por el usuario
      var boolean exit;
      let exit = false;
      
      while ((~exit) & (lives > 0)) {
         // Mostrar título e instrucciones
         do showTitle();
         do updateScore();
         // Esperar a que se presione una tecla
         while (key = 0) {
            let key = Keyboard.keyPressed();
            do moveBird();
            do updateObjects();  // Actualizar objetos cayendo
            do updateWalls();
         }
         if (key = 81)  { let exit = true; }     // Tecla Q
         if (key = 131) { let direction = 1; }   // Flecha arriba
         if (key = 133) { let direction = 2; }   // Flecha abajo
         if (key = 130) { let direction = 3; }   // Flecha izquierda
         if (key = 132) { let direction = 4; }   // Flecha derecha

         // Esperar a que se suelte la tecla
         while (~(key = 0)) {
            let key = Keyboard.keyPressed();
            do moveBird();
            do updateObjects();  // Actualizar objetos cayendo
            do updateWalls();
         }
      } // Fin del loop principal

      // Mostrar mensaje final
      do showGameOver();

      return;
   }

   // Muestra el título del juego.
   method void showTitle() {
      do Output.moveCursor(0, 1);
      do Output.printString("Score: ");
      do Output.moveCursor(0, 29);
      do Output.printString("FLIPFALL");
      return;
   }
   
   // Actualiza el score en pantalla.
   method void updateScore() {
      do Output.moveCursor(0, 8);
      do Output.printString("      ");  // Limpiar el área
      do Output.moveCursor(0, 8);
      do Output.printInt(score);
      return;
   }

   // Muestra el mensaje de Game Over.
   method void showGameOver() {
      do Output.moveCursor(10, 27);
      do Output.printString("GAME OVER!");
      do Output.moveCursor(11, 25);
      do Output.printString("Final Score: ");
      do Output.printInt(score);
      return;
   }

   // Actualiza todos los objetos cayendo y crea nuevos.
   method void updateObjects() {
      var int i;
      var FallingObject obj;
      var int birdX, birdY, birdSize;

      // Obtener posición del pájaro para detección de colisiones
      let birdX = bird.getX();
      let birdY = bird.getY();
      let birdSize = bird.getSize();
      
      let objectCount = objectCount + 1;
      let timeCounter = timeCounter + 1;

      // Manejar reactivación de objetos después de ser recolectados
      if (reactivationTimer > 0) {
         let reactivationTimer = reactivationTimer - 1;
         // Cuando el timer llegue a 0, reactivar todos los objetos inactivos
         if (reactivationTimer = 0) {
            let i = 0;
            while (i < maxObjects) {
               let obj = objects[i];
               if (~(obj = 0)) {
                  if (~(obj.isActive())) {
                     do obj.reactivate();
                  }
               }
               let i = i + 1;
            }
         }
      }
      
      // Incrementar score cada 2 segundos aproximadamente
      // (100 llamadas a updateObjects ≈ 2 segundos)
      if (timeCounter > 100) {
         let score = score + 1;
         do updateScore();
         let timeCounter = 0;
      }
      
      // Crear nuevo objeto cada cierto tiempo
      if (objectCount > 50) {
         do createRandomObject();
         let objectCount = 0;
      }
      
      // Actualizar todos los objetos existentes
      let i = 0;
      while (i < maxObjects) {
         let obj = objects[i];
         if (~(obj = 0)) {
            if (obj.isActive()) {
               do obj.fall();
               
               // Verificar colisión con el pájaro
               if (obj.checkCollision(birdX, birdY, birdSize)) {
                  if (obj.type() = 2) {        // Moneda recolectada
                     let score = score + 5;
                     do updateScore();
                  }

                  // Desactivar el objeto y programar su reactivación
                  do obj.deactivate();
                  let reactivationTimer = 100;
               }
            }
         }
         let i = i + 1;
      }
      
      return;
   }

   // Crea un objeto aleatorio en una posición aleatoria.
   method void createRandomObject() {
      var int i, randomX, randomSpeed;
      var FallingObject newObj;
      var boolean created;
      let i = 0;
      let created = false;

      while ((i < maxObjects) & (~created)) {

         if (objects[i] = 0) {

            // Calcular posición X pseudo-aleatoria
            let randomX = ((i * 97) + (objectCount * 37) + 50);
            while (randomX > 480) { let randomX = randomX - 480; }

            let randomSpeed = 1;

            // Crear solo monedas (tipo 2)
            let newObj = FallingObject.new(randomX, 2, randomSpeed);
            let objects[i] = newObj;
            let created = true;

         }

         let i = i + 1;
      }

      return;
   }

   // Actualiza los muros horizontales y verifica colisiones.
   method void updateWalls() {
      var int i;
      var HorizontalWall wall;
      var int birdX, birdY, birdSize;
      
      let birdX = bird.getX();
      let birdY = bird.getY();
      let birdSize = bird.getSize();
      
      let wallCounter = wallCounter + 1;

      // Crear nuevo muro cada cierto tiempo
      if (wallCounter > 200) {
         do createRandomWall();
         let wallCounter = 0;
      }
      
      // Actualizar y verificar colisiones con cada muro
      let i = 0;
      while (i < maxWalls) {
         let wall = horizontalWalls[i];
         if (~(wall = 0)) {
            do wall.fall();

            // Si hay colisión, terminar el juego
            if (wall.collidesWith(birdX, birdY, birdSize)) {
               let lives = 0;
            }
         }
         let i = i + 1;
      }
      return;
   }

   // Crea un muro horizontal en una posición aleatoria.
   method void createRandomWall() {
      var int i;
      var HorizontalWall newWall;
      var int randomGapX, randomSpeed;
      var boolean created;
      
      let i = 0;
      let created = false;

      while ((i < maxWalls) & (~created)) {
         if (horizontalWalls[i] = 0) {

            // Calcular posición X del hueco de forma pseudo-aleatoria
            let randomGapX = ((i * 157) + (wallCounter * 41) + 70);
            while (randomGapX > 400) { let randomGapX = randomGapX - 400; }
            while (randomGapX < 20)  { let randomGapX = randomGapX + 20; }

            let randomSpeed = 1;

            let newWall = HorizontalWall.new(0, randomGapX, randomSpeed);
            let horizontalWalls[i] = newWall;

            let created = true;
         }
         let i = i + 1;
      }

      return;
   }
}
