class BirdGame {
   field Bird bird;
   field int direction;
   
   // Sistema de Aviones
   field Array objects; 
   field int maxObjects;
   field int objectCount;
   field int reactivationTimer;

   // NUEVO: Sistema de Muros Horizontales
   field Array horizontalWalls;
   field int maxWalls;
   field int wallCounter;

   // Estado del juego
   field int lives;
   field int score;
   field int timeCounter;

   /** Constructs a new Bird game. */
   constructor BirdGame new() {
      var int i;
      let bird = Bird.new(256, 128, 30);
      let direction = 0;
      
      // Inicializar sistema de objetos cayendo
      let maxObjects = 5;
      let objects = Array.new(maxObjects);
      let objectCount = 0;
      let lives = 3;
      let score = 0;
      let timeCounter = 0;
      let reactivationTimer = 0;
      
      let i = 0;
      while (i < maxObjects) {
         let objects[i] = 0;
         let i = i + 1;
      }

      // Inicializar sistema de muros horizontales (NUEVO)
      let maxWalls = 3;
      let horizontalWalls = Array.new(maxWalls);
      let wallCounter = 0;
      let i = 0;
      while (i < maxWalls) {
          let horizontalWalls[i] = 0;
          let i = i + 1;
      }
      
      do showTitle();
      do updateLives();
      do updateScore();
      
      return this;
   }

   /** Disposes this game. */
   method void dispose() {
      var int i;
      var FallingObject obj;
      var HorizontalWall wall;
      
      // Liberar todos los objetos (aviones)
      let i = 0;
      while (i < maxObjects) {
         let obj = objects[i];
         if (~(obj = 0)) {
            do obj.dispose();
         }
         let i = i + 1;
      }
      
      // Liberar todos los muros (NUEVO)
      let i = 0;
      while (i < maxWalls) {
          let wall = horizontalWalls[i];
          if (~(wall = 0)) { do wall.dispose(); }
          let i = i + 1;
      }
      
      do objects.dispose();
      do horizontalWalls.dispose(); // NUEVO
      do bird.dispose();
      do Memory.deAlloc(this);
      return;
   }

   /** Moves the Bird in the current direction. */
   method void moveBird() {
      if (direction = 1) { do bird.moveUp(); }
      if (direction = 2) { do bird.moveDown(); }
      if (direction = 3) { do bird.moveLeft(); }
      if (direction = 4) { do bird.moveRight(); }
      do Sys.wait(5);  // delays the next movement
      return;
   }

   /** Runs the game: handles the user's inputs and moves the Bird accordingly */
   method void run() {
      var char key;
      var boolean exit;
      let exit = false;
      
      while ((~exit) & (lives > 0)) {
         // waits for a key to be pressed
         while (key = 0) {
            let key = Keyboard.keyPressed();
            do moveBird();
            do updateObjects();
            do updateWalls(); // NUEVO
         }
         if (key = 81)  { let exit = true; }
         if (key = 90)  { do bird.decSize(); }
         if (key = 88)  { do bird.incSize(); }
         if (key = 131) { let direction = 1; }
         if (key = 133) { let direction = 2; }
         if (key = 130) { let direction = 3; }
         if (key = 132) { let direction = 4; }

         // waits for the key to be released
         while (~(key = 0)) {
            let key = Keyboard.keyPressed();
            do moveBird();
            do updateObjects();
            do updateWalls(); // NUEVO
         }
     }
     
     do showGameOver();
     return;
   }
   
   /** Muestra el título del juego */
   method void showTitle() {
      do Output.moveCursor(0, 1);
      do Output.printString("Score: ");
      do Output.moveCursor(0, 29);
      do Output.printString("FLIPFALL");
      do Output.moveCursor(0, 55);
      do Output.printString("Lives: ");
      return;
   }
   
   /** Actualiza el score en pantalla */
   method void updateScore() {
      do Output.moveCursor(0, 8);
      do Output.printString("      ");  // Limpiar el área
      do Output.moveCursor(0, 8);
      do Output.printInt(score);
      return;
   }
   
   /** Actualiza las vidas en pantalla */
   method void updateLives() {
      do Output.moveCursor(0, 62);
      do Output.printString("   ");  // Limpiar el área
      do Output.moveCursor(0, 62);
      do Output.printInt(lives);
      return;
   }
   
   /** Muestra el mensaje de Game Over */
   method void showGameOver() {
      do Output.moveCursor(10, 27);
      do Output.printString("GAME OVER!");
      do Output.moveCursor(11, 25);
      do Output.printString("Final Score: ");
      do Output.printInt(score);
      return;
   }
   
   /** Actualiza todos los objetos cayendo y crea nuevos */
   method void updateObjects() {
      var int i;
      var FallingObject obj;
      var int birdX, birdY, birdSize;
      
      let birdX = bird.getX();
      let birdY = bird.getY();
      let birdSize = bird.getSize();
      
      let objectCount = objectCount + 1;
      let timeCounter = timeCounter + 1;
      
      if (reactivationTimer > 0) {
         let reactivationTimer = reactivationTimer - 1;
         if (reactivationTimer = 0) {
            let i = 0;
            while (i < maxObjects) {
               let obj = objects[i];
               if (~(obj = 0)) {
                  if (~(obj.isActive())) {
                     do obj.reactivate();
                  }
               }
               let i = i + 1;
            }
         }
      }
      
      if (timeCounter > 100) {
         let score = score + 1;
         do updateScore();
         let timeCounter = 0;
      }
      
      if (objectCount > 50) {
         do createRandomObject();
         let objectCount = 0;
      }
      
      let i = 0;
      while (i < maxObjects) {
         let obj = objects[i];
         if (~(obj = 0)) {
            if (obj.isActive()) {
               do obj.fall();
               
               if (obj.checkCollision(birdX, birdY, birdSize)) {
                  let lives = lives - 1;
                  do updateLives();
                  do obj.deactivate();
                  let reactivationTimer = 100;
               }
            }
         }
         let i = i + 1;
      }
      
      return;
   }
   
   /** Crea un objeto aleatorio en una posición aleatoria */
   method void createRandomObject() {
      var int i;
      var FallingObject newObj;
      var int randomX, randomSpeed;
      var boolean created;
      
      let i = 0;
      let created = false;
      while ((i < maxObjects) & (~created)) {
         if (objects[i] = 0) {
            let randomX = ((i * 97) + (objectCount * 37) + 50);
            while (randomX > 480) { let randomX = randomX - 480; }
            while (randomX < 0) { let randomX = randomX + 480; }
            let randomSpeed = 1;
            let newObj = FallingObject.new(randomX, 0, randomSpeed);
            let objects[i] = newObj;
            let created = true;
         }
         let i = i + 1;
      }
      return;
   }

   // --- LÓGICA DE MUROS HORIZONTALES (NUEVOS MÉTODOS) ---

   /** Actualiza todos los muros que caen y crea nuevos. */
   method void updateWalls() {
      var int i;
      var HorizontalWall wall;
      var int birdX, birdY, birdSize;
      
      let birdX = bird.getX();
      let birdY = bird.getY();
      let birdSize = bird.getSize();
      
      let wallCounter = wallCounter + 1;
      
      // Crear nuevo muro cada cierto tiempo
      if (wallCounter > 200) {
         do createRandomWall();
         let wallCounter = 0;
      }
      
      let i = 0;
      while (i < maxWalls) {
         let wall = horizontalWalls[i];
         if (~(wall = 0)) {
            do wall.fall();
            
            if (wall.collidesWith(birdX, birdY, birdSize)) {
               let lives = 0; // Game Over instantáneo
            }
         }
         let i = i + 1;
      }
      return;
   }
   
   /** Crea un muro horizontal aleatorio. */
   method void createRandomWall() {
      var int i;
      var HorizontalWall newWall;
      var int randomGapX, randomSpeed;
      var boolean created;
      
      let i = 0;
      let created = false;
      while ((i < maxWalls) & (~created)) {
         if (horizontalWalls[i] = 0) {
            // Generar X aleatoria para el hueco
            let randomGapX = ((i * 157) + (wallCounter * 41) + 70);
            while (randomGapX > 400) { let randomGapX = randomGapX - 400; }
            while (randomGapX < 20) { let randomGapX = randomGapX + 20; }
            
            let randomSpeed = 2;
            
            let newWall = HorizontalWall.new(0, randomGapX, randomSpeed);
            let horizontalWalls[i] = newWall;
            let created = true;
         }
         let i = i + 1;
      }
      return;
   }
}
