 
class BirdGame {
   field Bird bird; // the Bird of this game
   field int direction; // the Bird's current direction: 
                        // 0=none, 1=up, 2=down, 3=left, 4=right
   field Array objects; // Array de objetos cayendo
   field int maxObjects; // Número máximo de objetos
   field int objectCount; // Contador para crear nuevos objetos
   field int lives; // Vidas del jugador
   field int score; // Puntuación del jugador
   field int timeCounter; // Contador de tiempo para el score
   field int reactivationTimer; // Contador para reactivar objetos


   field Array horizontalWalls;
   field int maxWalls;
   field int wallCounter;

   /** Constructs a new Bird game. */
   constructor BirdGame new() {
      var int i;
      // The initial Bird is located in the middle of the screen (256,128), has size 30, and is not moving.
      let bird = Bird.new(256, 128, 30);
      let direction = 0;

      // Inicializar sistema de objetos cayendo
      let maxObjects = 5;  // Máximo 5 objetos en pantalla a la vez
      let objects = Array.new(maxObjects);
      let objectCount = 0;
      let lives = 3;  // Comenzar con 3 vidas
      let score = 0;  // Comenzar con score 0
      let timeCounter = 0;  // Inicializar contador de tiempo
      let reactivationTimer = 0;  // Sin objetos por reactivar al inicio
      
      // Inicializar array con null
      let i = 0;
      while (i < maxObjects) {
         let objects[i] = 0;  // null
         let i = i + 1;
      }

      let maxWalls = 3;
      let horizontalWalls = Array.new(maxWalls);
      let wallCounter = 0;

      let i = 0;
      while (i < maxWalls) {
         let horizontalWalls[i] = 0;
         let i = i + 1;
      }

      // Mostrar título e instrucciones
      do showTitle();
      // do updateLives();
      do updateScore();
      
      return this;
   }

   /** Disposes this game. */
   method void dispose() {
      var int i;
      var FallingObject obj;
      var HorizontalWall wall;

      // Liberar todos los objetos
      let i = 0;
      while (i < maxObjects) {
         let obj = objects[i];
         if (~(obj = 0)) { do obj.dispose(); }
         let i = i + 1;
      }

      let i = 0;
      while (i < maxWalls) {
         let wall = horizontalWalls[i];
         if (~(wall = 0)) { do wall.dispose(); }
         let i = i + 1;
      }

      do objects.dispose();
      do horizontalWalls.dispose();
      do bird.dispose();
      do Memory.deAlloc(this);
      return;
   }

   /** Moves the Bird in the current direction. */
   method void moveBird() {
      if (direction = 1) { do bird.moveUp(); }
      if (direction = 2) { do bird.moveDown(); }
      if (direction = 3) { do bird.moveLeft(); }
      if (direction = 4) { do bird.moveRight(); }
      do Sys.wait(8);  // delays the next movement
      return;
   }

   /** Runs the game: handles the user's inputs and moves the Bird accordingly */
   method void run() {
      var char key;  // the key currently pressed by the user
      var boolean exit;
      let exit = false;
      
      while ((~exit) & (lives > 0)) {
         // Mostrar título e instrucciones
         do showTitle();
         // do updateLives();
         do updateScore();
         // waits for a key to be pressed
         while (key = 0) {
            let key = Keyboard.keyPressed();
            do moveBird();
            do updateObjects();  // Actualizar objetos cayendo
            do updateWalls();
         }
         if (key = 81)  { let exit = true; }     // q key
         if (key = 90)  { do bird.decSize(); } // z key
         if (key = 88)  { do bird.incSize(); } // x key
         if (key = 131) { let direction = 1; }   // up arrow
         if (key = 133) { let direction = 2; }   // down arrow
         if (key = 130) { let direction = 3; }   // left arrow
         if (key = 132) { let direction = 4; }   // right arrow

         // waits for the key to be released
         while (~(key = 0)) {
            let key = Keyboard.keyPressed();
            do moveBird();
            do updateObjects();  // Actualizar objetos cayendo
            do updateWalls();
         }
      } // while

      // Mostrar mensaje final
      do showGameOver();

      return;
   }

   /** Muestra el título del juego */
   method void showTitle() {
      do Output.moveCursor(0, 1);
      do Output.printString("Score: ");
      do Output.moveCursor(0, 29);
      do Output.printString("FLIPFALL");
      // do Output.moveCursor(0, 55);
      // do Output.printString("Lives: ");
      return;
   }
   
   /** Actualiza el score en pantalla */
   method void updateScore() {
      do Output.moveCursor(0, 8);
      do Output.printString("      ");  // Limpiar el área
      do Output.moveCursor(0, 8);
      do Output.printInt(score);
      return;
   }

   /** Actualiza las vidas en pantalla */
   method void updateLives() {
      do Output.moveCursor(0, 62);
      do Output.printString("   ");  // Limpiar el área
      do Output.moveCursor(0, 62);
      do Output.printInt(lives);
      return;
   }

   /** Muestra el mensaje de Game Over */
   method void showGameOver() {
      do Output.moveCursor(10, 27);
      do Output.printString("GAME OVER!");
      do Output.moveCursor(11, 25);
      do Output.printString("Final Score: ");
      do Output.printInt(score);
      return;
   }

   /** Actualiza todos los objetos cayendo y crea nuevos */
   method void updateObjects() {
      var int i;
      var FallingObject obj;
      var int birdX, birdY, birdSize;

      // Obtener posición del pájaro para detección de colisiones
      let birdX = bird.getX();
      let birdY = bird.getY();
      let birdSize = bird.getSize();
      
      let objectCount = objectCount + 1;
      let timeCounter = timeCounter + 1;

      // Manejar reactivación de objetos
      if (reactivationTimer > 0) {
         let reactivationTimer = reactivationTimer - 1;
         // Cuando el timer llegue a 0, reactivar todos los objetos inactivos
         if (reactivationTimer = 0) {
            let i = 0;
            while (i < maxObjects) {
               let obj = objects[i];
               if (~(obj = 0)) {
                  if (~(obj.isActive())) {
                     do obj.reactivate();
                  }
               }
               let i = i + 1;
            }
         }
      }
      
      // Incrementar score cada 2 segundos
      // Aproximadamente 200 llamadas a updateObjects = 2 segundos
      if (timeCounter > 100) {
         let score = score + 1;
         do updateScore();
         let timeCounter = 0;
      }
      
      // Crear nuevo objeto solo al inicio si no existen
      if (objectCount > 50) {
         do createRandomObject();
         let objectCount = 0;
      }
      
      // Actualizar todos los objetos existentes
      let i = 0;
      while (i < maxObjects) {
         let obj = objects[i];
         if (~(obj = 0)) {
            if (obj.isActive()) {
               do obj.fall();
               
               // Verificar colisión con avión
               if (obj.checkCollision(birdX, birdY, birdSize)) {
                  // Colisión con avión - restar una vida
                  if (obj.type() = 0) {        // obstáculo
                     let lives = lives - 1;
                     do updateLives();
                  }

                  if (obj.type() = 1) {        // corazón
                     let lives = lives + 1;
                     do updateLives();
                  }

                  if (obj.type() = 2) {        // moneda
                     let score = score + 5;
                     do updateScore();
                  }

                  do obj.deactivate();
                  let reactivationTimer = 100;
               }
            }
         }
         let i = i + 1;
      }
      
      return;
   }

   /** Crea un objeto aleatorio en una posición aleatoria */
   method void createRandomObject() {
      var int i, randomX, randomSpeed, r;
      var FallingObject newObj;
      var boolean created;
      var int q, mod;
      let i = 0;
      let created = false;

      while ((i < maxObjects) & (~created)) {

         if (objects[i] = 0) {

            let randomX = ((i * 97) + (objectCount * 37) + 50);
            while (randomX > 480) { let randomX = randomX - 480; }

            let randomSpeed = 1;

            // "Aleatorio" de tipo usando timeCounter (pseudo-random)
            let r = timeCounter + (i * 3);

            // calcular r % 10

            let q = r / 10;
            let q = q * 10;
            let mod = r - q;     // mod = r % 10

            // 70% tipo 0
            /* if (mod < 7) {
               let newObj = FallingObject.new(randomX, 0, randomSpeed);
               let objects[i] = newObj;
               let created = true;
            }*/
            // 20% tipo 2
            // else {
               // volver a calcular mod si quieres reutilizar, pero no es necesario
               if (mod < 9) {
                  let newObj = FallingObject.new(randomX, 2, randomSpeed);
                  let objects[i] = newObj;
                  let created = true;
               }
               // 10% tipo 1
               else {

                  let newObj = FallingObject.new(randomX, 1, randomSpeed);
                  let objects[i] = newObj;
                  let created = true;
               }
            // } 

         }

         let i = i + 1;
      }

      return;
   }

   method void updateWalls() {
      var int i;
      var HorizontalWall wall;
      var int birdX, birdY, birdSize;
      
      let birdX = bird.getX();
      let birdY = bird.getY();
      let birdSize = bird.getSize();
      
      let wallCounter = wallCounter + 1;

      if (wallCounter > 200) {
         do createRandomWall();
         let wallCounter = 0;
      }
      
      let i = 0;
      while (i < maxWalls) {
         let wall = horizontalWalls[i];
         if (~(wall = 0)) {
            do wall.fall();

            if (wall.collidesWith(birdX, birdY, birdSize)) {
               let lives = 0;
            }
         }
         let i = i + 1;
      }
      return;
   }

   method void createRandomWall() {
      var int i;
      var HorizontalWall newWall;
      var int randomGapX, randomSpeed;
      var boolean created;
      
      let i = 0;
      let created = false;

      while ((i < maxWalls) & (~created)) {
         if (horizontalWalls[i] = 0) {

            let randomGapX = ((i * 157) + (wallCounter * 41) + 70);
            while (randomGapX > 400) { let randomGapX = randomGapX - 400; }
            while (randomGapX < 20)  { let randomGapX = randomGapX + 20; }

            let randomSpeed = 1;

            let newWall = HorizontalWall.new(0, randomGapX, randomSpeed);
            let horizontalWalls[i] = newWall;

            let created = true;
         }
         let i = i + 1;
      }

      return;
   }
}
